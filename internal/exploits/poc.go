package exploits

import (
	"fmt"
	"strings"

	"github.com/byteoverride/desynctrace/internal/client"
	"github.com/byteoverride/desynctrace/internal/vectors"
)

type PoC struct {
	Name        string
	Description string
	RawPayload  string
	CurlCommand string
}

type ExploitGenerator struct{}

func NewExploitGenerator() *ExploitGenerator {
	return &ExploitGenerator{}
}

func (e *ExploitGenerator) GeneratePoC(target string, vector vectors.SmugglingVector) (*PoC, error) {
	// Generate the attack payload
	baseReq := &client.Request{
		Method: "GET",
		URL:    target,
		Headers: map[string]string{
			"Host": "localhost",
		},
	}

	payloads := vector.GeneratePayloads(baseReq)
	if len(payloads) == 0 {
		return nil, fmt.Errorf("no payloads generated by vector")
	}

	// Take the first payload as the PoC
	payload := payloads[0]

	// Construct a representation
	var raw strings.Builder
	raw.WriteString(fmt.Sprintf("%s %s HTTP/1.1\r\n", payload.Method, payload.URL))
	for k, v := range payload.Headers {
		raw.WriteString(fmt.Sprintf("%s: %s\r\n", k, v))
	}
	if payload.TransferEncoding != "" {
		raw.WriteString(fmt.Sprintf("Transfer-Encoding: %s\r\n", payload.TransferEncoding))
	}
	if payload.ContentLength > 0 {
		raw.WriteString(fmt.Sprintf("Content-Length: %d\r\n", payload.ContentLength))
	}
	raw.WriteString("\r\n")
	raw.Write(payload.Body)

	poc := &PoC{
		Name:        fmt.Sprintf("%s Exploit", vector.Name()),
		Description: "Run this payload to demonstrate HTTP Smuggling",
		RawPayload:  raw.String(),
		CurlCommand: fmt.Sprintf("curl -X %s %s -H 'Transfer-Encoding: chunked' ...", payload.Method, target), // Placeholder
	}

	return poc, nil
}
